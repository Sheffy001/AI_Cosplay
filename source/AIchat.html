<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>AI è§’è‰²æ‰®æ¼”èŠå¤©</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      display: flex;
      height: 100vh;
      background: #f5f5f5;
    }

    /* å·¦ä¾§æ  */
    .sidebar {
      width: 260px;
      background: #2f3542;
      color: white;
      display: flex;
      flex-direction: column;
    }

    .sidebar-header {
      padding: 15px;
      background: #374151;
      border-bottom: 1px solid #444;
    }

    .sidebar-header h3 {
      margin: 0;
      font-size: 16px;
    }

    .sidebar-header small {
      font-size: 12px;
      color: #aaa;
    }

    .chat-list {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
    }

    .chat-item {
      padding: 10px;
      margin-bottom: 5px;
      background: #3a3f47;
      border-radius: 5px;
      cursor: pointer;
    }

    .chat-item:hover {
      background: #4a5568;
    }

    /* å³ä¾§èŠå¤© */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    .chat-messages {
      flex: 1;
      padding: 20px;
      overflow-y: auto;
    }

    .message {
      margin-bottom: 15px;
    }

    .message.user {
      text-align: right;
    }

    .message.user .content {
      display: inline-block;
      background-color: #0084ff;
      color: white;
      padding: 10px;
      border-radius: 10px;
    }

    /* ä¿®æ”¹æœºå™¨äººæ¶ˆæ¯æ ·å¼ */
    .message.assistant {
      display: flex;
      align-items: flex-start;
      gap: 8px;
    }

    .message.assistant .content {
      background-color: #e5e5ea;
      color: black;
      padding: 10px;
      border-radius: 10px;
      flex: 1;
      min-width: 0;
    }

    /* å–‡å­æŒ‰é’®æ ·å¼ */
    .speaker-btn {
      background: #4CAF50;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      color: white;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-top: 5px;
      flex-shrink: 0;
      /* é˜²æ­¢æŒ‰é’®è¢«å‹ç¼© */
      transition: all 0.2s;
    }

    .speaker-btn:hover {
      background: #45a049;
      transform: scale(1.1);
    }

    .speaker-btn:active {
      transform: scale(0.95);
    }

    .speaker-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .input-container {
      display: flex;
      padding: 10px;
      border-top: 1px solid #ccc;
    }

    .input-container input {
      flex: 1;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 5px;
    }

    .input-container button {
      margin-left: 10px;
      padding: 10px 20px;
      font-size: 16px;
      background-color: #0084ff;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .input-container button:hover {
      background-color: #006bbf;
    }
  </style>
  <script>
    const currentUser = {};
  </script>
</head>

<body>
  <!-- å·¦ä¾§æ  -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h3 id="username"></h3>
      <small id="user-info"></small>
    </div>
    <div class="chat-list" id="chat-list"><!-- è‡ªåŠ¨åŠ è½½ï¼Œä¸è¿›è¡Œç¡¬ç¼–ç  --></div>
  </div>

  <!-- å³ä¾§èŠå¤©åŒº -->
  <div class="chat-container">
    <div class="chat-messages" id="chat-messages"></div>
    <div class="input-container">
      <input type="text" id="user-input" placeholder="è¯·è¾“å…¥æ¶ˆæ¯..." />
      <button id="send-button">å‘é€</button>
      <button id="mic-button">ğŸ¤</button>
    </div>
  </div>


  <script>
    const roleVoiceMap = {};
    async function loadRoleList() {
      try {
        const resp = await fetch("/role", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ type: "mult", roleid: "0" })
        });

        if (!resp.ok) throw new Error(`HTTP error! status: ${resp.status}`);
        const data = await resp.json();
        if (!data.success) throw new Error("è·å–è§’è‰²åˆ—è¡¨å¤±è´¥");

        const chatListDiv = document.getElementById("chat-list");

        // æ¸…ç©ºåŸæœ‰HTMLç¡¬ç¼–ç é¡¹
        chatListDiv.innerHTML = "";

        // éå†æ¥å£è¿”å›ï¼Œåˆ›å»ºåˆ—è¡¨é¡¹å¹¶ç»‘å®šç‚¹å‡»äº‹ä»¶
        data.roleinfo.forEach(role => {
          const div = document.createElement("div");
          div.classList.add("chat-item");
          div.dataset.chatid = role.roleid;
          div.textContent = role.rolename;

          // ç‚¹å‡»äº‹ä»¶
          div.addEventListener("click", () => {
            loadChat(role.roleid);
          });

          chatListDiv.appendChild(div);

          // ä¿å­˜è¯­éŸ³ç±»å‹æ˜ å°„
          roleVoiceMap[role.roleid] = role.voicetype || "qiniu_zh_female_tmjxxy";
        });

        roleVoiceMap["default"] = "qiniu_zh_female_tmjxxy";

        // é»˜è®¤åŠ è½½ç¬¬ä¸€ä¸ªè§’è‰²èŠå¤©
        if (data.roleinfo.length > 0) {
          await loadChat(data.roleinfo[0].roleid);
        }
      } catch (err) {
        console.error("åŠ è½½è§’è‰²åˆ—è¡¨å¤±è´¥:", err);
      }
    }
    loadRoleList();
    // const chatListDiv = document.getElementById('chat-list');
    const chatMessagesDiv = document.getElementById('chat-messages');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');


    let currentChatId = null;
    let conversationHistory = [];
    

    // ä¿®æ”¹æ¸²æŸ“æ¶ˆæ¯å‡½æ•°
    function addMessage(content, sender, showSpeaker = true) {
      const messageDiv = document.createElement('div');
      messageDiv.classList.add('message', sender);

      const contentDiv = document.createElement('div');
      contentDiv.classList.add('content');
      contentDiv.textContent = content;

      if (sender === 'assistant' && showSpeaker) {
        // ä¸ºæœºå™¨äººæ¶ˆæ¯æ·»åŠ å–‡å­æŒ‰é’®
        const speakerBtn = document.createElement('button');
        speakerBtn.classList.add('speaker-btn');
        speakerBtn.innerHTML = 'ğŸ”Š';
        speakerBtn.title = 'ç‚¹å‡»æ’­æ”¾è¯­éŸ³';

        speakerBtn.addEventListener('click', function () {
          speakerBtn.disabled = true;
          speakerBtn.innerHTML = 'â³';
          speakerBtn.title = 'æ­£åœ¨æ’­æ”¾...';

          speakTTS(content, currentChatId).finally(() => {
            speakerBtn.disabled = false;
            speakerBtn.innerHTML = 'ğŸ”Š';
            speakerBtn.title = 'ç‚¹å‡»æ’­æ”¾è¯­éŸ³';
          });
        });

        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(speakerBtn);
      } else {
        messageDiv.appendChild(contentDiv);
      }

      chatMessagesDiv.appendChild(messageDiv);
      chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
    }
    //gushihuoqu
    async function getRoleDefaultMessage(chatId) {
      try {
        const storyResp = await fetch("/role", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ roleid: chatId, type: "signal" })
        });

        if (!storyResp.ok) throw new Error(`HTTP error! status: ${storyResp.status}`);
        const storyData = await storyResp.json();

        if (!storyData.success) {
          console.warn("æœªæ‰¾åˆ°è¯¥è§’è‰²æ•…äº‹");
          return null; // æˆ–è€… return ""
        }

        return storyData.roleinfo;

      } catch (err) {
        console.error("è·å–è§’è‰²æ•…äº‹å¤±è´¥:", err);
        return null;
      }
    }
    async function getRoleStroy(chatId) {
      try {
        const storyResp = await fetch("/story", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ roleid: chatId })
        });

        if (!storyResp.ok) throw new Error(`HTTP error! status: ${storyResp.status}`);
        const storyData = await storyResp.json();

        if (!storyData.success) {
          console.warn("æœªæ‰¾åˆ°è¯¥è§’è‰²æ•…äº‹");
          return null; // æˆ–è€… return ""
        }

        return storyData.story;

      } catch (err) {
        console.error("è·å–è§’è‰²æ•…äº‹å¤±è´¥:", err);
        return null; // å‡ºé”™æ—¶è¿”å› nullï¼Œè°ƒç”¨æ–¹è‡ªå·±å¤„ç†
      }
    }



    


    // åŠ è½½å†å²èŠå¤©
    async function loadChat(chatId) {
      currentChatId = chatId;
      chatMessagesDiv.innerHTML = '';
      if (!currentUser.userId) {
        try {
          const userResp = await fetch("/userinfo", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({}) // åç«¯ä¸éœ€è¦è¯·æ±‚ä½“å¯ä¸ºç©º
          });

          if (!userResp.ok) throw new Error(`HTTP error! status: ${userResp.status}`);
          const userData = await userResp.json();

          if (!userData.success) {
            alert("ç”¨æˆ·æœªç™»å½•æˆ– Session å·²è¿‡æœŸ");
            window.location.href = "/login.html";
            return;
          }

          // ä¿å­˜ç”¨æˆ·ä¿¡æ¯åˆ°å…¨å±€ currentUser
          currentUser.userId = userData.userId;
          currentUser.username = userData.username;
          currentUser.maxchatid = userData.maxchatid;

          // æ›´æ–°å·¦ä¾§æ æ˜¾ç¤º
          document.getElementById("username").innerText = "ç”¨æˆ·: " + currentUser.username;
          document.getElementById("user-info").innerText =
            "UID: " + currentUser.userId + " | maxChatId: " + currentUser.maxchatid;

        } catch (err) {
          console.error("è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:", err);
          alert("è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–é‡æ–°ç™»å½•");
          window.location.href = "/login.html";
          return;
        }
      }

      const roleStory = await getRoleStroy(currentChatId);
      conversationHistory = [{
        role: "system",
        content: `ç°åœ¨ä½ æ˜¯ä¸‹é¢è¿™ä¸ªæ•…äº‹çš„ä¸»è§’ï¼Œè¯·ä»¥ä¸»è§’è§†è§’å’Œæˆ‘èŠå¤©ï¼š${roleStory}`
      }];

      try {
        const resp = await fetch('/history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ userid: currentUser.userId, chatid: currentChatId })
        });
        const data = await resp.json();
        const history = data.messages || [];

        if (history.length > 0) {
          // æ•°æ®åº“æœ‰æ¶ˆæ¯
          history.forEach(msg => {
            addMessage(msg.message, msg.role === 'user' ? 'user' : 'assistant');
            conversationHistory.push({ role: msg.role, content: msg.message });
          });
        } else {
          // æ²¡æœ‰æ¶ˆæ¯ï¼Œæ¸²æŸ“é»˜è®¤å¼€åœºç™½
          const defaultMsg = await getRoleDefaultMessage(currentChatId) || "é»˜è®¤å¼€åœºç™½";
          addMessage(defaultMsg, 'assistant');
          conversationHistory.push({ role: 'assistant', content: defaultMsg });
        }
      } catch (err) {
        console.error('åŠ è½½å†å²æ¶ˆæ¯å¤±è´¥', err);
        const defaultMsg = getRoleDefaultMessage(currentChatId);
        addMessage(defaultMsg, 'assistant');
        conversationHistory.push({ role: 'assistant', content: defaultMsg });
      }
    }

    // ä¿å­˜æ¶ˆæ¯åˆ°æœåŠ¡å™¨
    async function saveMessage(userMessage, botMessage) {
      try {
        await fetch('/Save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            userid: currentUser.userId,
            chatid: currentChatId,
            user_message: userMessage,
            bot_message: botMessage
          })
        });
      } catch (err) {
        console.error('ä¿å­˜å¤±è´¥:', err);
        alert('æ¶ˆæ¯ä¿å­˜å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥');
      }
    }

    function filterDialogue(text) {
      // å»æ‰ *xxx* æˆ– [xxx]
      return text.replace(/(\*.*?\*|\[.*?\])/g, "").trim();
    }

    // å‘é€æ¶ˆæ¯ï¼ˆä¿®æ”¹åçš„ç‰ˆæœ¬ï¼‰
    async function sendMessage() {
      if (!currentChatId) { alert("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè§’è‰²"); return; }
      const message = userInput.value.trim();
      if (!message) return;
      addMessage(message, 'user');
      conversationHistory.push({ role: "user", content: message });
      userInput.value = '';

      const replyDiv = document.createElement('div');
      replyDiv.classList.add('message', 'bot');
      const replyContent = document.createElement('div');
      replyContent.classList.add('content');
      replyDiv.appendChild(replyContent);
      chatMessagesDiv.appendChild(replyDiv);

      try {
        const qiniuResp = await fetch("https://openai.qiniu.com/v1/chat/completions", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "sk-646dfa7895e2b087d59916715de791794f8782f060e661222342aef5b920491a"
          },
          body: JSON.stringify(
            {
              model: "gpt-oss-120b",
              messages: conversationHistory,
              stream: true
            }
          )
        });

        if (!qiniuResp.ok) {
          throw new Error(`HTTP error! status: ${qiniuResp.status}`);
        }

        const reader = qiniuResp.body.getReader();
        const decoder = new TextDecoder("utf-8");
        replyContent.textContent = "";
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          let lines = buffer.split("\n");
          buffer = lines.pop();

          for (let line of lines) {
            line = line.trim();
            if (!line.startsWith("data:")) continue;

            const jsonStr = line.replace(/^data:\s*/, "");
            if (jsonStr === "[DONE]") continue;

            try {
              const data = JSON.parse(jsonStr);
              const content = data.choices?.[0]?.delta?.content;
              if (content) {
                replyContent.textContent += content;
                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
              }


            } catch (e) {
              // JSONä¸å®Œæ•´ï¼Œä¸‹ä¸€è½®å†å¤„ç†
            }
          }
        }

        // æµå¼å›å¤å®Œæˆåï¼Œä¸ºè¿™ä¸ªæ¶ˆæ¯æ·»åŠ å–‡å­æŒ‰é’®
        const speakerBtn = document.createElement('button');
        speakerBtn.classList.add('speaker-btn');
        speakerBtn.innerHTML = 'ğŸ”Š';
        speakerBtn.title = 'ç‚¹å‡»æ’­æ”¾è¯­éŸ³';

        speakerBtn.addEventListener('click', function () {
          speakerBtn.disabled = true;
          speakerBtn.innerHTML = 'â³';
          speakerBtn.title = 'æ­£åœ¨æ’­æ”¾...';

          speakTTS(replyContent.textContent, currentChatId).finally(() => {
            speakerBtn.disabled = false;
            speakerBtn.innerHTML = 'ğŸ”Š';
            speakerBtn.title = 'ç‚¹å‡»æ’­æ”¾è¯­éŸ³';
          });
        });

        replyDiv.appendChild(speakerBtn);

        // è‡ªåŠ¨æ’­æ”¾ä¸€æ¬¡
        speakTTS(replyContent.textContent, currentChatId);
        conversationHistory.push({ role: "assistant", content: replyContent.textContent });

        // è°ƒç”¨ç‹¬ç«‹çš„ä¿å­˜å‡½æ•°
        await saveMessage(message, replyContent.textContent);

      } catch (err) {
        console.error(err);
        replyContent.textContent = "æŠ±æ­‰ï¼ŒAI ç”Ÿæˆå¤±è´¥";
      }
    }

    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keypress', e => { if (e.key === 'Enter') sendMessage(); });

    const micButton = document.getElementById('mic-button');

    // è¯­éŸ³è¾“å…¥
    let recognizing = false;
    let recognition;

    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      recognition = new SpeechRecognition();
      recognition.lang = 'zh-CN'; // ä¸­æ–‡
      recognition.continuous = false; // ä¸€æ¬¡è¯†åˆ«ä¸€æ¬¡
      recognition.interimResults = false;

      recognition.onstart = () => { recognizing = true; micButton.textContent = 'ğŸ™ï¸ å½•éŸ³ä¸­...'; };
      recognition.onend = () => { recognizing = false; micButton.textContent = 'ğŸ¤'; };
      recognition.onerror = (e) => { console.error(e); recognizing = false; micButton.textContent = 'ğŸ¤'; };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        userInput.value = transcript; // å¡«å…¥è¾“å…¥æ¡†
        sendMessage(); // è‡ªåŠ¨å‘é€ï¼Œå¯åˆ é™¤æ”¹ä¸ºæ‰‹åŠ¨ç‚¹å‡»å‘é€
      };
    }

    micButton.addEventListener('click', () => {
      if (!recognition) {
        alert('ä½ çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
        return;
      }
      if (recognizing) {
        recognition.stop();
      } else {
        recognition.start();
      }
    });




    // ä¿®æ”¹TTSå‡½æ•°ï¼Œè¿”å›Promiseä»¥ä¾¿å¤„ç†å®ŒæˆçŠ¶æ€
    async function speakTTS(text, chatId) {
      const voiceType = roleVoiceMap[chatId] || roleVoiceMap["default"];
      try {
        const resp = await fetch("https://openai.qiniu.com/v1/voice/tts", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer sk-646dfa7895e2b087d59916715de791794f8782f060e661222342aef5b920491a"
          },
          body: JSON.stringify({
            audio: {
              voice_type: voiceType,
              encoding: "mp3",
              speed_ratio: 1.3,
            },
            request: { text }
          })
        });

        if (!resp.ok) {
          throw new Error(`ä¸ƒç‰›äº‘ TTS è¯·æ±‚å¤±è´¥ï¼Œstatus: ${resp.status}`);
        }

        const data = await resp.json();
        const base64Audio = data.data; // TTS è¿”å›çš„ base64 éŸ³é¢‘
        const audio = new Audio("data:audio/mp3;base64," + base64Audio);

        return new Promise((resolve, reject) => {
          audio.onended = resolve;
          audio.onerror = reject;
          audio.play();
        });

      } catch (err) {
        console.error("TTS æ’­æ”¾å¤±è´¥:", err);
        // å¤±è´¥æ—¶å¯å›é€€åˆ°æµè§ˆå™¨ TTS
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'zh-CN';
        utterance.pitch = 1;
        utterance.rate = 1;

        return new Promise((resolve) => {
          utterance.onend = resolve;
          speechSynthesis.speak(utterance);
        });
      }
    }

  </script>

</body>

</html>